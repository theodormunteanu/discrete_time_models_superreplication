# -*- coding: utf-8 -*-
"""
Created on Fri Dec 14 10:31:53 2018

@author: frup74094
"""
import sys
sys.path.append(r'C:\Users\Theodor\Documents\python army of functions2\Interest_rate_futures')
from date_diff import date_diff
#%%
def binomial_tree(S0,n,u,d=None,f = None):
    if d == None:
        d = 1/u
    import inspect
    if f==None:
        return [[S0*u**(m-k) * d**k for k in range(0,m+1)] for m in range(0,n+1)]
    elif inspect.isfunction(f)==True:
        tree = [[S0*u**(m-k) * d**k for k in range(0,m+1)] for m in range(0,n+1)]
        return [list(map(f,tree[i])) for i in range(len(tree))]

def binomial_tree1(S0,n,u,d = None):
    if d==None:
        d=1/u
    return [[S0*u**(m-k)*d**k for k in range(0,m+1)] for m in range(0,n+1)]

def binomial_tree2(S0,f,n,u,d = None):
    r"""
    Description:
    -----------
    
    We compute the payoff tree given by f by starting from the binomial tree 
    generated by `S0`, `n` and `u`.
    
    For each node `x`, we compute then the transformed node `f(x)` 
    
    Parameters:
    ----------
    
    `f`: lambda function of one parameter
    """
    if d==None:
        d = 1/u
    tree = [[S0*u**(m-k)*d**k for k in range(0,m+1)] for m in range(0,n+1)]
    return [[f(tree[i][j]) for j in range(len(tree[i]))] for i in range(len(tree))]

def binomial_tree2bis(S0,f,n,u,d = None):
    r"""
    Description:
    -----------
    
    """
    if d==None:
        d = 1/u
    tree = [[S0 * u**(m-k) * d**k for k in range(0,m+1)] for m in range(0,n+1)]
    #from functools import map
    import inspect
    if inspect.isfunction(f) == True:
       return [list(map(f,tree[i])) for i in range(len(tree))] 

def probability_tree(n, p):
    from functools import reduce
    def comb(n,k):
        if n==0 or k==0 or k==n:
            return 1
        else:
            return reduce((lambda x,y:x*y),range(1,n+1))/\
            (reduce((lambda x,y:x*y),range(1,k+1)) * reduce((lambda x,y:x*y),range(1,n-k+1)))
    return [[comb(m,k)* p**(m-k) * (1-p)**k for k in range(0,m+1)] for m in range(0,n+1)]

class binomial_model:
    def __init__(self,S0,r,T,f):
        if S0>0:
           self.S0 = S0
        else:
            raise TypeError('the underlying value cannot be negative')
        self.r = r
        if T>=0:
           self.T = T
        else:
            raise TypeError('the time to maturity must be positive')
        from inspect import isfunction
        if isfunction(f):
           self.f = f
        else:
            raise TypeError('{0} must be a function'.format(f))
    
    def european_option_price(self,n,u,d = None,prob = None):
        S0,r,T,f = self.S0,self.r,self.T,self.f
        import numpy as np
        h = T/n
        tree = binomial_tree(S0,n,u,d,f)
        if d==None:
            d=1/u
        if prob==None:
            prob = (np.exp(r*h)-d)/(u-d)
        l = [[0]*j for j in range(1,n+2)]
        l[-1] = tree[-1]
        for i in range(n-1,-1,-1):
            l[i] = [np.exp(-r*h)*(prob*l[i+1][j]+(1-prob)*l[i+1][j+1]) for j in range(0,i+1)]
        return l

    def american_option_price(self,n,p,u,d = None):
        S0,r,T,f = self.S0,self.r,self.T,self.f
        import numpy as np
        h = T/n
        tree = binomial_tree(S0,n,u,d,f)
        l = [[0]*j for j in range(1,n+2)]
        l[-1] = tree[-1]
        for i in range(n-1,-1,-1):
            l[i] = [max(tree[i][j],np.exp(-r*h)*(p*l[i+1][j]+(1-p)*l[i+1][j+1])) for j in range(0,i+1)]
        return l

    def european_option_price2(self,n,sig,q=0,underlying = 'equity'):
        r,T = self.r,self.T
        import numpy as np
        h = T/n
        u = np.exp(sig*np.sqrt(h))
        if underlying == 'equity':
           p = (np.exp((r-q)*h)-1/u)/(u-1/u)
        elif underlying == 'futures':
           p = (1-1/u)/(u-1/u)
        return self.european_option_price(n,u,prob = p)[0][0]

    def american_option_price2(self, n, sig, q=0,underlying = 'equity'):
        r,T = self.r,self.T
        import numpy as np
        h = T/n
        u = np.exp(sig*np.sqrt(h))
        if underlying == 'equity':
           p = (np.exp((r-q)*h)-1/u)/(u-1/u)
        elif underlying == 'futures':
           p = (1-1/u)/(u-1/u)
        return self.american_option_price(n,p,u)[0][0]

    def implied_vol(self, n, mkt_price, q=0, \
                option = 'european',underlying = 'equity'):
        if option == 'european':
            g = lambda sig: self.european_option_price2(n,sig,q,underlying)-mkt_price
        elif option == 'american':
            g = lambda sig: self.american_option_price2(n,sig,q,underlying)-mkt_price
        import scipy.optimize as opt
        return opt.newton(g,0.1)
    
    def implied_vol2(self,n,mkt_price, date1,date2,q=0, \
                     option = 'european',underlying = 'equity'):
        obj = date_diff(date1,date2)
        T = obj.time_diff()
        self.T = T
        return self.implied_vol(n,mkt_price,q=0,\
                    option = 'european',underlying = 'equity')
#%%
def european_option_price(S0,r,T,f,n,u,d = None,prob = None,underlying = 'equity'):
    import numpy as np
    h = T/n
    tree = binomial_tree(S0,n,u,d,f)
    if d==None:
        d=1/u
    if prob==None:
        if underlying == 'equity':
           prob = (np.exp(r*h)-d)/(u-d)
        elif underlying == 'futures':
           prob = (1-d)/(u-d)
    l = [[0]*j for j in range(1,n+2)]
    l[-1] = tree[-1]
    for i in range(n-1,-1,-1):
        l[i] = [np.exp(-r*h)*(prob*l[i+1][j]+(1-prob)*l[i+1][j+1]) for j in range(0,i+1)]
    return l

def american_option_price(S0,r,T,f,n,u,d = None,p = None,underlying = 'equity'):
    import numpy as np
    h = T/n
    tree = binomial_tree(S0,n,u,d,f)
    l = [[0]*j for j in range(1,n+2)]
    l[-1] = tree[-1]
    if d==None:
        d = 1/u
    if p == None or p==[]:
        if underlying == 'equity':
            p = (np.exp(r*h)-d)/(u-d)
        elif underlying == 'futures':
            p = (1-d)/(u-d)
    for i in range(n-1,-1,-1):
        l[i] = [max(tree[i][j],np.exp(-r*h)*(p*l[i+1][j]+(1-p)*l[i+1][j+1])) for j in range(0,i+1)]
    return l

def european_option_price2(S0,r,T,f,n,sig,q=0,underlying = 'equity'):
    import numpy as np
    h = T/n
    u = np.exp(sig*np.sqrt(h))
    if underlying == 'equity':
       p = (np.exp((r-q)*h)-1/u)/(u-1/u)
    elif underlying == 'futures':
       p = (1-1/u)/(u-1/u)
    return european_option_price(S0,r,T,f,n,u,prob = p)[0][0]

def american_option_price2(S0, r, T, f, n, sig, q=0,underlying = 'equity'):
    import numpy as np
    h = T/n
    u = np.exp(sig*np.sqrt(h))
    if underlying == 'equity':
       p_ = (np.exp((r-q)*h)-1/u)/(u-1/u)
    elif underlying == 'futures':
       p_ = (1-1/u)/(u-1/u)
    return american_option_price(S0,r,T,f,n,u,p = p_)[0][0]

#%% 
def implied_vol(S0, r, T, f, n, mkt_price, q=0, \
                option = 'european',underlying = 'equity'):
    if option == 'european':
        g = lambda sig: european_option_price2(S0,r,T,f,n,sig,q,underlying)-mkt_price
    elif option == 'american':
        g = lambda sig: american_option_price2(S0,r,T,f,n,sig,q,underlying)-mkt_price
    import scipy.optimize as opt
    return opt.newton(g,0.1)
#%%
def breakeven_strike(S0,r,T,n,u,d,underlying_ = 'equity', option = 'call'):
    """
    For american options we find the limit strike price for which it is optimal 
    to exercise the option immediately"""
    f1 = lambda K:(S0-K)*(S0>K)
    f2 = lambda K:(K-S0)*(K>S0)
    def amer_price_call(K):
        f = lambda x: (x-K)*(x>K)
        return american_option_price(S0,r,T,f,n,u,d,underlying = underlying_)[0][0]
    def amer_price_put(K):
        f = lambda x: (K-x)*(x<K)
        return american_option_price(S0,r,T,f,n,u,d,underlying = underlying_)[0][0]
    if option == 'call':
        g = lambda K:f1(K)-amer_price_call(K)
    elif option == 'put':
        g = lambda K:f2(K)-amer_price_put(K)
    import scipy.optimize as opt
    return opt.newton(g,S0)
        
